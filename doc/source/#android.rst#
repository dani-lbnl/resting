Android app development
=======================

Installation of development tools
---------------------------------

Having access to emulators is important for us, and it appears that the easiest way to get those is by installing Android Studio. This can be downloaded at https://developer.android.com/studio . I installed the 64-bit Linux package, with a download size of 865 MB, following the directions at https://developer.android.com/studio/install . The ``studio.sh`` script is used to start Android Studio and will download and install an emulator by default when first run, requiring an additional download of a little under 2 GB.

Android project organization
----------------------------

This guide describes the creation of a simple Android project https://developer.android.com/training/basics/firstapp/creating-project . This is the full user guide https://developer.android.com/studio/intro .

Upon creating a new project, Android Studio populates the project directories with minimal project files. It will also detect if the user-specified project directory is within directories that are under Git version control. I created a new project using the "Simple Activity" template.

Immediately after creating the new project, one can start the emulator automatically by running the app by pressing Shift-F10. This starts the emulator and starts the app within the emulator. Clicking on the emulator screen seems equivalent to tapping on the touchscreen of an actual device. Clicking and dragging seems equivalent to swiping on a real touchscreen. I've never used an Android phone. The "square" button at the bottom allows one to select from among running applications (after which dragging upward kills an app). The "circle" button appears to place all applications in the background. The "triangle" button appears to reverse the last navigation action in most cases.

The following describes the initial setup of the "Simple Activity."

For maximum accessibility, one can choose the mininmum Android version. Even then, it appears that the app uses the ``androidx`` library, which isn't included by default in early installations of Android. One might have to select legacy library compatibility if we want users to be able to avoid downloads, although installing this app also requires a download, so maybe an additional library download isn't a real obstacle for users.

Under ``java > com.example.demonstration``, the ``MainActivity.kt`` file is the app entry point and specifically references ``R.layout.activity_main`` in the ``onCreate`` method. I think is what gives ``activity_main.xml`` (under ``app > res > layout``) its signficance. ``R`` probably stands for resource, associated with the ``res`` folder. The ``activity_main.xml`` file defines a ``toolbar`` that is subsequently referenced as ``R.id.toolbar``. Next, ``MainActivity.kt`` references ``R.id.fab``, which is also defined in ``activity_main.xml`` and is associated with an action button.

I think that the ``onCreate`` method is like an app constructor, but that other methods (such as the ``onCreateOptionsMenu``, also in ``MainActivity.kt``) are run upon app startup as well. The ``onCreateOptionsMenu`` method references ``R.menu.menu_main``, which seems to be a reference to ``menu_main.xml``. Finally, I'm not sure what the ``onOptionsItemSelected`` routine does. It's associated with the "action bar," although I don't know what that is.

The next hints to the system must come from the XML files referenced by ``MainActivity.kt``. It seems that  ``activity_main.xml`` describes the overall layout, describing the toolbar (where the app title is printed) as part of the ``AppBarLayout`` as well as the floating action button. These reference some information that I haven't yet located. This XML file ``include``s the ``content_main.xml`` as the ``layout`` attribute, which seems to describe the layout of the screen minus the toolbar. Then ``content_main.xml`` references ``nav_graph.xml`` (under ``app > res > navigation``) as ``navGraph``. Note that one can switch between code and visual representations using the buttons toward the upper right of the Android Studio window.

In ``nav_graph.xml``, there are definitions and corresponding references to the ``fragment_first.xml`` file that appears to govern the layout that is initially visible in the content area, and ``fragment_second.xml``, which describes what is seen after clicking on the ``next`` button in the emulator. Code (``FirstFragment.kt`` and ``SecondFragment.kt``) is referenced in ``nav_graph.xml``. The "fragment" XML files seem to describe visual layout but no actions.  Associated transitions that connect the two fragments are declared in ``nav_graph.xml``.

The ``FirstFragment.kt`` file references ``R.layout.fragment_first``, and the ``SecondFragment.kt`` file references ``R.layout.fragment_second``. These Kotlin files are not referenced by ``MainActivity.kt``, so the only link seems to be through ``nav_graph.xml``. They also have references to ``R.id.action_FirstFragment_to_SecondFragment`` and ``R.id.action_SecondFragment_to_FirstFragment``, declared in the ``nav_graph.xml`` file, and probably connection actions to the declared transisions.

Data, including settings, are frequently stored in XML format and referenced, rather than being hard-coded into the Kotlin files.

Sample project
--------------

We aim to demonstrate how to create an app that can collect and send data to our website and receive the results of calculations, also from our website. Only a minimal user interface should be needed.

The app will download data from the website without using authentication and display the content.

To do this, we will need to figure out how to transfer the data and store it in a way that is accessible throughout the app. I believe that once the app (``com.example.demonstration``) is started, all of its code runs as within a single program with access to global variables. If this is not the case, it might be necessary to create temporary files.

According to https://developer.android.com/training/basics/network-ops/connecting , network operations should not be performed in the user interface thread. One can read more about processes and thread at https://developer.android.com/guide/components/processes-and-threads .

We will use a single application process (as with most Android apps) but two threads. When a button is clicked, the corresponding Listener will start a new Thread that sends an HTTPS request to the web server and receives a reply. 

The "Debug" Build Type (Build > Select Build Variant) is selected by default, so the debugger should be immediately available. It is also possible to send data to a log, which can assist in the debugging process:
https://developer.android.com/studio/debug/

It seems that there are different types of scope in Android apps. XML files are used to describe what is displayed on screen, and there are hierarchies of Views that are automatically searched for specific objects. The XML files can define connections to other XML files. Computation is described in source code files that reference the corresponding XML display descriptions, and scope is managed by the programming language that is used. There are multiple approaches to referencing XML file contents from executable code. The most fundamental approach uses methods that search file contents for items of interest, but there are also "view" and "data" bindings that use additional libraries and auto-generate glue code.
https://developer.android.com/topic/libraries/data-binding/expressions

Listeners are typically passed a View object, and there are methods that search a hierarchy beginning at given View object. However, the View object that is passed for a button click seems to correspond to the Button in question, which typically does not head much of a hierarchy. To change another UI element, the Listener needs some other mechanism for accessing the UI element that doesn't involve finding that element by searching a hierarchy.


